snippet #
#if $1
#endif // $1
endsnippet

snippet i
#include <${1:iostream}>
endsnippet

snippet ii
#include "${1:myheader}.hpp"
endsnippet

snippet tem
template<typename ${1:T}>
endsnippet

snippet ttem
template<template <typename> class ${1:T}>
endsnippet

snippet cla
class ${1:ClassName}
{
public:
    $3
private:
	$2
};
endsnippet

snippet str
struct ${1:StructName}
{
    $2
};
endsnippet

snippet if
if ( ${1:true} ) {
    $2
}
endsnippet

snippet ifel
if ( ${1:true} ) {
    $2
} else {
    $3
}
endsnippet

snippet elif
else if ( ${1:true} ) {
    $2
}
endsnippet

snippet el
else {
    $1
}
endsnippet

snippet do
do {
    $2
} while ( ${1:true} );
endsnippet

snippet while
while ( ${1:true} ) {
    $2
}
endsnippet

snippet getopt
while ( true )
{
    /* struct option {
     *	   const char* name ; // long option name
     *     int      has_arg ; // no_argument, required_argument, optional_argument
     *     int        *flag ; // function return val when flag==NULL
     *     int          val ; // function return a int to represent this long option
     * };
     */
    static option LongOpts[] {
        {"version", no_argument, 0, 'v'},
        {"help",    no_argument, 0, 'h'},
        {${1:struct_option}},
        {0, 0, 0, 0}
    };
    auto choice = getopt_long(argc, argv, "vh$2", LongOpts, nullptr);
    if ( choice == -1 ) break;
    switch ( choice ) {
        case 'v':
            $3
            break;
        case 'h':
            $4
            break;
        case '?':
            break ;
    }
}
while ( optind < argc ) {
    $5
}
endsnippet

## STL Collections
# std::array
snippet arr  "description" w
std::array<${1:T}, ${2:N}> ${3};
endsnippet

# std::vector
snippet vec  "description" w
std::vector<${1:T}> ${2};
endsnippet

# std::deque
snippet deq  "description" w
std::deque<${1:T}> ${2};
endsnippet

# std::forward_list
snippet fls  "description" w
std::forward_list<${1:T}> ${2};
endsnippet

# std::list
snippet ls  "description" w
std::list<${1:T}> ${2};
endsnippet

# std::set
snippet set  "description" w
std::set<${1:T}> ${2};
endsnippet

# std::map
snippet map  "description" w
std::map<${1:Key}, ${2:T}> ${3};
endsnippet

# std::multiset
snippet mset  "description" w
std::multiset<${1:T}> ${2};
endsnippet

# std::multimap
snippet mmap  "description" w
std::multimap<${1:Key}, ${2:T}> ${3};
endsnippet

# std::unordered_set
snippet uset  "description" w
std::unordered_set<${1:T}> ${2};
endsnippet

# std::unordered_map
snippet umap  "description" w
std::unordered_map<${1:Key}, ${2:T}> ${3};
endsnippet

# std::unordered_multiset
snippet umset  "description" w
std::unordered_multiset<${1:T}> ${2};
endsnippet

# std::unordered_multimap
snippet ummap  "description" w
std::unordered_multimap<${1:Key}, ${2:T}> ${3};
endsnippet

# std::stack
snippet stack  "description" w
std::stack<${1:T}> ${2};
endsnippet

# std::queue
snippet queue  "description" w
std::queue<${1:T}> ${2};
endsnippet

# std::priority_queue
snippet pqueue  "description" w
std::priority_queue<${1:T}> ${2};
endsnippet

##
## STL smart pointers
# std::shared_ptr
snippet msp  "description" w
auto ${1} = std::make_shared<${2:T}>(${3});
endsnippet

# std::unique_ptr
snippet mup  "description" w
auto ${1} = make_unique<${2:T}>(${3});
endsnippet

snippet cerr  "description" w
std::cerr << ${1};
endsnippet

# std::cout
snippet cout  "description" w
std::cout << ${1};
endsnippet

snippet coul  "description" w
std::cout << ${1} << std::endl;
endsnippet

snippet fuck  "description" w
std::cout << "\e[31mfuck:\e[m " ${1:<< } << std::endl;
endsnippet

snippet coutf  "description" w
std::cout << ${1} << std::flush;
endsnippet

# std::cin
snippet cin  "description" w
std::cin >> ${1};
endsnippet

##
## Casts
# static
snippet sc  "description" w
static_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

# const
snippet cc  "description" w
const_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

# reinterpret
snippet rc  "description" w
reinterpret_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

# dynamic
snippet dc  "description" w
dynamic_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

snippet for  "description" w
for ( ${1:int i\{\}}; ${2:i < num}; ${3:++i} ) {
    ${4}
}
endsnippet

# range-based
snippet forr  "description" w
for ( auto& ${1:t} : ${1:container} ) {
    ${2}
}
endsnippet

snippet ld  "description" w
[${1}] (${2}) {
    ${3}
};
endsnippet

snippet try  "description" w
try {
    $1
} catch(${2}) {
    $3
}
endsnippet

snippet acm  "description" w
#include <algorithm>
#include <iostream>
#include <iterator>
#include <limits>
#include <numeric>

int main()
{
    $1

    return 0;
}

endsnippet

snippet core  "description" w
#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <iterator>
#include <limits>
#include <numeric>

TEST(TestSuit, TestCase)
{

}
endsnippet

snippet init  "description" w
#include <iostream>

#include "mine.hpp"

int main()
{
    $1

    return 0;
}

endsnippet

snippet main  "description" w
int main()
{
    $1

    return 0;
}
endsnippet

snippet maina  "description" w
int main(int argc, char* argv[])
{

    $1

    return 0;
}
endsnippet

snippet arg  "description" w
int argc, char* argv[]
endsnippet

snippet na "description" w
namespace${1:}
{
	$2
} // namespace$1
endsnippet

snippet sp "description" w
/*************************************************************************************************/
// $1
/*************************************************************************************************/
endsnippet

